package com.reach_android.util

import kotlinx.coroutines.delay
import kotlin.math.pow
import kotlin.math.sqrt
import kotlin.math.tanh
import kotlin.random.Random

/**
 * Exponential backoff with decorrelated jitter. This should be considered the optimal Jitter stategy
 * for most scenarios, as battle-tested in Polly.
 *
 * By default, the generator produces delay values with a backoff calculated in seconds with a maximum
 * of 30 seconds. A scaling factor can be specified in the constructor.
 *
 * https://github.com/App-vNext/Polly/issues/530
 * https://github.com/Polly-Contrib/Polly.Contrib.WaitAndRetry/blob/24cb116a2a320e82b01f57e13bfeaeff2725ccbf/src/Polly.Contrib.WaitAndRetry/Backoff.DecorrelatedJitterV2.cs
 *
 * @param scale Scaling factor applied to the return value
 * @param maxDelay Maximum delay in ms
 */
internal class JitterGenerator(
    private val scale: Double = 1.0,
    private val maxDelay: Long = 30000
) {
    /**
     * Last state of the jitter generator function
     */
    private var attempt: Int = 0
    private var prev: Double = 0.0

    /**
     * Calculate the next delay value using the jitter generator
     * @returns delay in ms
     */
    fun next(): Long = (generator() * scale).toLong().coerceAtMost(maxDelay)

    private fun generator(): Double {
        val t = attempt + Random.nextDouble()
        val next = 2.0.pow(t) * tanh(sqrt(pFactor * t))

        val result = next - prev
        attempt += 1
        prev = next
        return result.coerceAtLeast(0.0) * rpScalingFactor * 128
    }

    companion object {
        /**
         * A factor used within the formula to help smooth the first calculated delay.
         */
        const val pFactor = 4.0

        /**
         *  A factor used to scale the median values of the retry times generated by
         * the formula to be _near_ whole seconds, to aid user comprehension. This
         * factor allows the median values to fall approximately at 1, 2, 4 etc
         * seconds, instead of 1.4, 2.8, 5.6, 11.2.
         */
        const val rpScalingFactor = 1 / 1.4

        suspend fun <T> retry(times: Int, action: suspend () -> T): T {
            val retryDelay by lazy { JitterGenerator() }
            var lastException: Throwable? = null
            for (i in 0..times) {
                if(i > 0) delay(retryDelay.next())
                try {
                    return action()
                } catch (e: Throwable) {
                    lastException = e
                }
            }
            throw lastException ?: UnknownError()
        }
    }
}